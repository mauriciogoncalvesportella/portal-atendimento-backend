"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invertSort = exports.applyQuery = exports.applyPaging = exports.applySort = exports.applyFilter = exports.getFilterFields = exports.mergeQuery = exports.mergeFilter = exports.transformQuery = exports.transformFilter = exports.transformSort = void 0;
const tslib_1 = require("tslib");
const lodash_merge_1 = tslib_1.__importDefault(require("lodash.merge"));
const interfaces_1 = require("../interfaces");
const filter_builder_1 = require("./filter.builder");
const sort_builder_1 = require("./sort.builder");
const page_builder_1 = require("./page.builder");
exports.transformSort = (sorting, fieldMap) => {
    if (!sorting) {
        return undefined;
    }
    return sorting.map((sf) => {
        const field = fieldMap[sf.field];
        if (!field) {
            throw new Error(`No corresponding field found for '${sf.field}' when transforming SortField`);
        }
        return { ...sf, field };
    });
};
exports.transformFilter = (filter, fieldMap) => {
    if (!filter) {
        return undefined;
    }
    return Object.keys(filter).reduce((newFilter, filterField) => {
        var _a;
        if (filterField === 'and' || filterField === 'or') {
            return { ...newFilter, [filterField]: (_a = filter[filterField]) === null || _a === void 0 ? void 0 : _a.map((f) => exports.transformFilter(f, fieldMap)) };
        }
        const fromField = filterField;
        const otherKey = fieldMap[fromField];
        if (!otherKey) {
            throw new Error(`No corresponding field found for '${filterField}' when transforming Filter`);
        }
        return { ...newFilter, [otherKey]: filter[fromField] };
    }, {});
};
exports.transformQuery = (query, fieldMap) => {
    return {
        filter: exports.transformFilter(query.filter, fieldMap),
        paging: query.paging,
        sorting: exports.transformSort(query.sorting, fieldMap),
    };
};
exports.mergeFilter = (base, source) => {
    if (!Object.keys(base).length) {
        return source;
    }
    if (!Object.keys(source).length) {
        return base;
    }
    return { and: [source, base] };
};
exports.mergeQuery = (base, source) => {
    return lodash_merge_1.default(base, source);
};
exports.getFilterFields = (filter) => {
    const fieldSet = Object.keys(filter).reduce((fields, filterField) => {
        if (filterField === 'and' || filterField === 'or') {
            const andOrFilters = filter[filterField];
            if (andOrFilters !== undefined) {
                return andOrFilters.reduce((andOrFields, andOrFilter) => {
                    return new Set([...andOrFields, ...exports.getFilterFields(andOrFilter)]);
                }, fields);
            }
        }
        else {
            fields.add(filterField);
        }
        return fields;
    }, new Set());
    return [...fieldSet];
};
function applyFilter(dtoOrArray, filter) {
    const filterFunc = filter_builder_1.FilterBuilder.build(filter);
    if (Array.isArray(dtoOrArray)) {
        return dtoOrArray.filter((dto) => filterFunc(dto));
    }
    return filterFunc(dtoOrArray);
}
exports.applyFilter = applyFilter;
exports.applySort = (dtos, sortFields) => {
    return sort_builder_1.SortBuilder.build(sortFields)(dtos);
};
exports.applyPaging = (dtos, paging) => {
    return page_builder_1.PageBuilder.build(paging)(dtos);
};
exports.applyQuery = (dtos, query) => {
    var _a, _b, _c;
    const filtered = applyFilter(dtos, (_a = query.filter) !== null && _a !== void 0 ? _a : {});
    const sorted = exports.applySort(filtered, (_b = query.sorting) !== null && _b !== void 0 ? _b : []);
    return exports.applyPaging(sorted, (_c = query.paging) !== null && _c !== void 0 ? _c : {});
};
function invertSort(sortFields) {
    return sortFields.map((sf) => {
        const direction = sf.direction === interfaces_1.SortDirection.ASC ? interfaces_1.SortDirection.DESC : interfaces_1.SortDirection.ASC;
        let nulls;
        if (sf.nulls === interfaces_1.SortNulls.NULLS_LAST) {
            nulls = interfaces_1.SortNulls.NULLS_FIRST;
        }
        else if (sf.nulls === interfaces_1.SortNulls.NULLS_FIRST) {
            nulls = interfaces_1.SortNulls.NULLS_LAST;
        }
        return { ...sf, direction, nulls };
    });
}
exports.invertSort = invertSort;
//# sourceMappingURL=query.helpers.js.map