import { FilterComparisonOperators, Filter, FilterFieldComparison } from '../interfaces';
import { ComparisonField, FilterFn } from './types';
export declare const isComparison: <DTO, K extends keyof DTO>(maybeComparison: (DTO[K] extends string | String ? import("../interfaces").StringFieldComparisons : DTO[K] extends boolean | Boolean ? import("../interfaces").BooleanFieldComparisons : DTO[K] extends null | undefined ? import("../interfaces").BooleanFieldComparisons : DTO[K] extends number | bigint | symbol | RegExp | Date | (string | number | bigint | boolean | symbol | RegExp | Date | null | undefined)[] ? import("../interfaces").CommonFieldComparisonType<DTO[K]> : DTO[K] extends (infer U)[] ? import("../interfaces").CommonFieldComparisonType<U> | Filter<U> : Filter<DTO[K]> | import("../interfaces").CommonFieldComparisonType<DTO[K]>) | Filter<DTO[K]>) => maybeComparison is DTO[K] extends string | String ? import("../interfaces").StringFieldComparisons : DTO[K] extends boolean | Boolean ? import("../interfaces").BooleanFieldComparisons : DTO[K] extends null | undefined ? import("../interfaces").BooleanFieldComparisons : DTO[K] extends number | bigint | symbol | RegExp | Date | (string | number | bigint | boolean | symbol | RegExp | Date | null | undefined)[] ? import("../interfaces").CommonFieldComparisonType<DTO[K]> : DTO[K] extends (infer U)[] ? import("../interfaces").CommonFieldComparisonType<U> | Filter<U> : Filter<DTO[K]> | import("../interfaces").CommonFieldComparisonType<DTO[K]>;
export declare class ComparisonBuilder {
    static build<DTO, F extends keyof DTO>(field: F, cmp: FilterComparisonOperators<DTO[F]>, val: ComparisonField<DTO, F>): FilterFn<DTO>;
    private static booleanComparison;
    private static rangeComparison;
    private static likeComparison;
    private static inComparison;
    private static betweenComparison;
    private static likeSearchToRegexp;
}
