"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComparisonBuilder = exports.isComparison = void 0;
const compare = (filter, fallback) => {
    return (dto) => (dto ? filter(dto) : fallback);
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isLikeComparisonOperator = (op) => {
    return op === 'like' || op === 'notLike' || op === 'iLike' || op === 'notILike';
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isInComparisonOperators = (op) => {
    return op === 'in' || op === 'notIn';
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isBetweenComparisonOperators = (op) => {
    return op === 'between' || op === 'notBetween';
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isRangeComparisonOperators = (op) => {
    return op === 'gt' || op === 'gte' || op === 'lt' || op === 'lte';
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isBooleanComparisonOperators = (op) => {
    return op === 'eq' || op === 'neq' || op === 'is' || op === 'isNot';
};
exports.isComparison = (maybeComparison) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return Object.keys(maybeComparison).every((op) => {
        return (isLikeComparisonOperator(op) ||
            isInComparisonOperators(op) ||
            isBetweenComparisonOperators(op) ||
            isRangeComparisonOperators(op) ||
            isBooleanComparisonOperators(op));
    });
};
class ComparisonBuilder {
    static build(field, cmp, val) {
        if (isBooleanComparisonOperators(cmp)) {
            return this.booleanComparison(cmp, field, val);
        }
        if (isRangeComparisonOperators(cmp)) {
            return this.rangeComparison(cmp, field, val);
        }
        if (isInComparisonOperators(cmp)) {
            return this.inComparison(cmp, field, val);
        }
        if (isLikeComparisonOperator(cmp)) {
            return this.likeComparison(cmp, field, val);
        }
        if (isBetweenComparisonOperators(cmp)) {
            return this.betweenComparison(cmp, field, val);
        }
        throw new Error(`unknown operator ${JSON.stringify(cmp)}`);
    }
    static booleanComparison(cmp, field, val) {
        if (cmp === 'neq') {
            return (dto) => (dto ? dto[field] : null) !== val;
        }
        if (cmp === 'isNot') {
            // eslint-disable-next-line eqeqeq
            return (dto) => (dto ? dto[field] : null) != val;
        }
        if (cmp === 'eq') {
            return (dto) => (dto ? dto[field] : null) === val;
        }
        // eslint-disable-next-line eqeqeq
        return (dto) => (dto ? dto[field] : null) == val;
    }
    static rangeComparison(cmp, field, val) {
        if (cmp === 'gt') {
            return compare((dto) => dto[field] > val, false);
        }
        if (cmp === 'gte') {
            return compare((dto) => dto[field] >= val, false);
        }
        if (cmp === 'lt') {
            return compare((dto) => dto[field] < val, false);
        }
        return compare((dto) => dto[field] <= val, false);
    }
    static likeComparison(cmp, field, val) {
        if (cmp === 'like') {
            const likeRegexp = this.likeSearchToRegexp(val);
            return compare((dto) => likeRegexp.test(dto[field]), false);
        }
        if (cmp === 'notLike') {
            const likeRegexp = this.likeSearchToRegexp(val);
            return compare((dto) => !likeRegexp.test(dto[field]), true);
        }
        if (cmp === 'iLike') {
            const likeRegexp = this.likeSearchToRegexp(val, true);
            return compare((dto) => likeRegexp.test(dto[field]), false);
        }
        const likeRegexp = this.likeSearchToRegexp(val, true);
        return compare((dto) => !likeRegexp.test(dto[field]), true);
    }
    static inComparison(cmp, field, val) {
        if (cmp === 'notIn') {
            return compare((dto) => !val.includes(dto[field]), true);
        }
        return compare((dto) => val.includes(dto[field]), false);
    }
    static betweenComparison(cmp, field, val) {
        const { lower, upper } = val;
        if (cmp === 'notBetween') {
            return compare((dto) => {
                const dtoVal = dto[field];
                return dtoVal < lower || dtoVal > upper;
            }, true);
        }
        return compare((dto) => {
            const dtoVal = dto[field];
            return dtoVal >= lower && dtoVal <= upper;
        }, false);
    }
    static likeSearchToRegexp(likeStr, caseInsensitive = false) {
        const replaced = likeStr.replace(/%/g, '.*');
        return new RegExp(`^${replaced}$`, caseInsensitive ? 'ig' : 'g');
    }
}
exports.ComparisonBuilder = ComparisonBuilder;
//# sourceMappingURL=comparison.builder.js.map